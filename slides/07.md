---
presentation:
  margin: 0
  center: false
  transition: "convex"
  enableSpeakerNotes: true
  slideNumber: "c/t"
  navigationMode: "linear"
---

@import "../css/font-awesome-4.7.0/css/font-awesome.css"
@import "../css/theme/solarized.css"
@import "../css/logo.css"
@import "../css/font.css"
@import "../css/color.css"
@import "../css/margin.css"
@import "../css/table.css"
@import "../css/main.css"
@import "../plugin/zoom/zoom.js"
@import "../plugin/customcontrols/plugin.js"
@import "../plugin/customcontrols/style.css"
@import "../plugin/chalkboard/plugin.js"
@import "../plugin/chalkboard/style.css"
@import "../plugin/menu/menu.js"
@import "../js/anychart/anychart-core.min.js"
@import "../js/anychart/anychart-venn.min.js"
@import "../js/anychart/pastel.min.js"
@import "../js/anychart/venn-ml.js"

<!-- slide data-notes="" -->

<div class="bottom20"></div>

# 机器学习

<hr class="width50 center">

## 神经网络

<div class="bottom8"></div>

### 计算机学院 &nbsp;&nbsp; 张腾

#### _tengzhang@hust.edu.cn_

<!-- slide vertical=true data-notes="" -->

##### 大纲

---

@import "../vega/outline.json" {as="vega" .top-2}

<!-- slide vertical=true data-notes="" -->

##### 发展历史

---

@import "../mermaid/nn.mermaid"

<div class="top-2"></div>

- 八十年代红极一时：x86 系列 CPU 和内存条技术较七十年代显著提高
- 近十年梅开二度：大数据防止过拟合，显卡等计算设备性能显著提升

<!-- slide data-notes="" -->

##### 神经网络

---

@import "../dot/nn.dot" {.center}

<div class="top0"></div>

- 黄色部分就是个 M-P 神经元模型
- 大量的神经元并行串联就构成了神经网络
- 只要存在隐藏层，神经网络就拥有了非线性分类能力

<!-- slide vertical=true data-notes="" -->

##### 形式化

---

引入下面的记号：

- $L$：神经网络的层数
- $n_l$：第$l$层神经元的个数
- $h_l(\cdot)$：第$l$层的激活函数
- $\Wv_l \in \Rbb^{n_l \times n_{l-1}}$：第$l-1$层到第$l$层的权重矩阵
- $\bv_l \in \Rbb^{n_l}$：第$l$层的偏置 (截距)
- $\zv_l \in \Rbb^{n_l}$：第$l$层神经元的输入
- $\av_l \in \Rbb^{n_l}$：第$l$层神经元的输出

<div class="top4"></div>

神经网络第$l$层的计算过程：$\zv_l = \Wv_l \av_{l-1} + \bv_l$，$\av_l = h_l (\zv_l)$

整个网络：$\xv = \av_0 \xrightarrow{\Wv_1,\bv_1} \zv_1 \xrightarrow{h_1} \av_1 \xrightarrow{\Wv_2,\bv_2} \cdots \xrightarrow{\Wv_L,\bv_L} \zv_L \xrightarrow{h_L} \av_L = \hat{\yv}$

<!-- slide data-notes="" -->

##### 激活函数

---

最早的 M-P 模型采用阶跃函数$\sgn(\cdot)$作为激活函数

改进方向：

- 连续并几乎处处可导，可以高效计算
- 导数的值域在合适的范围内，否则影响用梯度下降进行训练

<div class="top2"></div>

常见的有

- Sigmoid 型：对率函数，双曲正切函数
- ReLU，带泄漏的 ReLU，带参数的 ReLU，ELU，Softplus
- Swish 函数
- Maxout 单元

<!-- slide vertical=true data-notes="" -->

##### <span style="font-weight:900">Sigmoid</span> 型

---

@import "../python/Sigmoid.svg" {.width60 .center .top6}

<!-- slide vertical=true data-notes="" -->

##### 对率函数

---

将$\Rbb$<span class="blue">挤压</span>到$[0,1]$，输出拥有{==概率==}意义：

$$
\begin{align*}
    \qquad \sigma(z) = \frac{1}{1 + \exp (-z)} = \begin{cases}
        1, & z \rightarrow \infty \\
        0, & z \rightarrow -\infty
    \end{cases}
\end{align*}
$$

对率函数连续可导，在<span class="blue">零处导数最大</span>

$$
\begin{align*}
    \qquad \nabla \sigma(z) = \sigma(z) (1 - \sigma(z)) \le \left( \frac{\sigma(z) + 1 - \sigma(z)}{2} \right)^2 = \frac{1}{4}
\end{align*}
$$

<div class="top-3"></div>

均值不等式等号成立的条件是$\sigma(z) = 1 - \sigma(z)$，即$z = 0$

<!-- slide vertical=true data-notes="" -->

##### 双曲正切函数

---

将$\Rbb$<span class="blue">挤压</span>到$[-1,1]$，<span class="blue">输出零中心化</span>，对率函数的放大平移

$$
\begin{align*}
    \qquad \tanh(z) & = \frac{\exp(z) - \exp(-z)}{\exp(z) + \exp(-z)} = \frac{1 - \exp(-2z)}{1 + \exp(-2z)} = 2 \sigma(2z) - 1 \\[2pt]
    & = \begin{cases}
        1, & z \rightarrow \infty \\
        -1, & z \rightarrow -\infty
    \end{cases} \\[10pt]
    \nabla \tanh(z) & = 4 \sigma(2z) (1 - \sigma(2z)) \le 1
\end{align*}
$$

双曲正切函数连续可导，在$z = 0$处导数最大

输出零中心化使得非输入层的输入都在零附近，而双曲正切函数在零处导数最大，梯度下降更新效率较高，对率函数输出恒为正，会减慢梯度下降的收敛速度

<!-- slide data-notes="" -->

##### 整流线性单元

---

整流线性单元 (<u>re</u>ctified <u>l</u>inear <u>u</u>nit, ReLU)：

$$
\begin{align*}
    \qquad \relu(z) = \max \{ 0, z \} = \begin{cases}
        z & z \ge 0 \\ 0 & z < 0
    \end{cases}
\end{align*}
$$

<div class="top-2"></div>

优点

- 计算只涉及加法、乘法和比较操作，非常高效
- 生物学解释：单侧抑制，宽兴奋边界，稀疏兴奋
- 在$z > 0$时导数恒为$1$，缓解了<span class="blue">梯度消失</span>问题

<div class="top2"></div>

缺点

- 输出非零中心化，对下一层不友好
- 死亡 ReLU 问题：对异常值特别敏感

<!-- slide vertical=true data-notes="" -->

##### 死亡 <span style="font-weight:900">ReLU</span> 问题

---

由链式法则有

$$
\begin{align*}
    \qquad \nabla_{\wv} \relu(\wv^\top \xv + b) & = \frac{\partial \relu(\wv^\top \xv + b)}{\partial (\wv^\top \xv + b)} \frac{\partial (\wv^\top \xv + b)}{\partial \wv} \\
    & = \frac{\partial \max \{ 0, \wv^\top \xv + b \}}{\partial (\wv^\top \xv + b)} \xv \\
    & = \Ibb(\wv^\top \xv + b \ge 0) \xv
\end{align*}
$$

如果第一个隐藏层中的某个神经元对应的$(\wv,b)$初始化不当，使得对任意$\xv$有$\wv^\top \xv + b < 0$，那么其关于$(\wv,b)$的梯度将为零，在以后的训练过程中永远不会被更新

解决方案：带泄漏的 ReLU，带参数的 ReLU，ELU，Softplus

<!-- slide vertical=true data-notes="" -->

##### <span style="font-weight:900">ReLU</span> 变体

---

带泄漏的 ReLU：当$\wv^\top \xv + b < 0$时也有非零梯度

$$
\begin{align*}
    \qquad \lrelu(z) & = \begin{cases}
        z & z \ge 0 \\ \gamma z & z < 0
    \end{cases} \\
    & = \max \{ 0, z \} + \gamma \min \{ 0, z \} \overset{\gamma < 1}{=} \max \{ z, \gamma z \}
\end{align*}
$$

<div class="top-3"></div>

其中斜率$\gamma$是一个很小的常数，比如$0.01$

带参数的 ReLU：斜率$\gamma_i$可学习

$$
\begin{align*}
    \qquad \prelu(z) & = \begin{cases}
        z & z \ge 0 \\ \gamma_i z & z < 0
    \end{cases} \\[4pt]
    & = \max \{ 0, z \} + \gamma_i \min \{ 0, z \}
\end{align*}
$$

<div class="top-3"></div>

可以不同神经元有不同的参数，也可以一组神经元共享一个参数

<!-- slide vertical=true data-notes="" -->

##### <span style="font-weight:900">ReLU</span> 变体

---

指数线性单元 (<u>e</u>xponential <u>l</u>inear <u>u</u>nit, ELU)

$$
\begin{align*}
    \qquad \elu(z) & = \begin{cases}
        z & z \ge 0 \\ \gamma (\exp(z) - 1) & z < 0
    \end{cases} \\[4pt]
    & = \max \{ 0, z \} + \min \{ 0, \gamma (\exp(z) - 1) \}
\end{align*}
$$

Softplus 函数可以看作 ReLU 的平滑版本：

$$
\begin{align*}
    \qquad \softplus(z) = \ln (1 + \exp(z))
\end{align*}
$$

其导数为对率函数

$$
\begin{align*}
    \qquad \nabla \softplus(z) = \frac{\exp(z)}{1 + \exp(z)} = \frac{1}{1 + \exp(-z)}
\end{align*}
$$

<!-- slide vertical=true data-notes="" -->

##### <span style="font-weight:900">ReLU</span> 族

---

@import "../python/ReLU.svg" {.width60 .center .top6}

<!-- slide data-notes="自门控的意思是控制自己是否激活的\sigma (\beta z)也跟有关" -->

##### <span style="font-weight:900">Swish</span> 函数

---

Swish 函数是一种自门控 (self-gated) 激活函数：

$$
\begin{align*}
    \qquad \swish(z) = z \cdot \sigma (\beta z) = \frac{z}{1 + \exp(-\beta z)}
\end{align*}
$$

<div class="top-4"></div>

其中$\beta$是可学习的参数或一个固定超参数

- 当$\sigma (\beta z)$接近于$1$时，门处于<span class="blue">开</span>状态，激活函数的输出近似于$z$本身
- 当$\sigma (\beta z)$接近于$0$时，门处于<span class="blue">关</span>状态，激活函数的输出近似于$0$

<!-- slide vertical=true data-notes="" -->

##### <span style="font-weight:900">Swish</span> 函数

---

@import "../python/Swish.svg" {.width60 .center .top6}

<!-- slide vertical=true data-notes="" -->

##### <span style="font-weight:900">Maxout</span> 单元

---

考虑神经网络的第$l$层：

$$
\begin{align*}
    \qquad \zv_l & = \Wv_l \av_{l-1} + \bv_l \\
    \av_l & = h_l (\zv_l)
\end{align*}
$$

<div class="top-4"></div>

前面提到的激活函数都是$\Rbb \mapsto \Rbb$的，即$[\av_l]_i = h_l ([\zv_l]_i), ~ i \in [n_l]$

Maxout 单元是$\Rbb^{n_l} \mapsto \Rbb$的，输入就是$\zv_l$，其定义为

$$
\begin{align*}
    \qquad \maxout (\zv) = \max_{k \in [K]} \{ \wv_k^\top \zv + b_k \}
\end{align*}
$$

- 整体学习输入到输出间的非线性关系
- $\relu(z) = \max \{ 0, z \}$与$\lrelu(z) \overset{\gamma < 1}{=} \max \{ z, \gamma z \}$都是 Maxout 单元的特例

