---
presentation:
  margin: 0
  center: false
  transition: "convex"
  enableSpeakerNotes: true
  slideNumber: "c/t"
  navigationMode: "linear"
---

@import "../css/font-awesome-4.7.0/css/font-awesome.css"
@import "../css/theme/solarized.css"
@import "../css/logo.css"
@import "../css/font.css"
@import "../css/color.css"
@import "../css/margin.css"
@import "../css/table.css"
@import "../css/main.css"
@import "../plugin/zoom/zoom.js"
@import "../plugin/customcontrols/plugin.js"
@import "../plugin/customcontrols/style.css"
@import "../plugin/chalkboard/plugin.js"
@import "../plugin/chalkboard/style.css"
@import "../plugin/menu/menu.js"
@import "../js/anychart/anychart-core.min.js"
@import "../js/anychart/anychart-venn.min.js"
@import "../js/anychart/pastel.min.js"
@import "../js/anychart/venn-ml.js"

<!-- slide data-notes="" -->

<div class="bottom20"></div>

# 机器学习

<hr class="width50 center">

## 神经网络

<div class="bottom8"></div>

### 计算机学院 &nbsp;&nbsp; 张腾

#### _tengzhang@hust.edu.cn_

<!-- slide vertical=true data-notes="" -->

##### 大纲

---

@import "../vega/outline.json" {as="vega" .top-2}

<!-- slide vertical=true data-notes="" -->

##### 发展历史

---

@import "../mermaid/nn.mermaid"

<div class="top-2"></div>

- 八十年代红极一时：x86 系列 CPU 和内存条技术较七十年代显著提高
- 近十年梅开二度：大数据防止过拟合，显卡等计算设备性能显著提升

<!-- slide data-notes="" -->

##### 神经网络

---

@import "../dot/nn.dot" {.center}

<div class="top0"></div>

- 每个圆圈对应一个神经元，黄色部分就是个感知机或对率回归
- 大量的神经元并行串联就构成了神经网络
- 只要存在隐藏层，神经网络就拥有了非线性分类能力

<!-- slide vertical=true data-notes="" -->

##### 形式化

---

引入下面的记号：

- $L$：神经网络的层数
- $n_l$：第$l$层神经元的个数
- $h_l(\cdot)$：第$l$层的激活函数
- $\Wv_l \in \Rbb^{n_l \times n_{l-1}}$：第$l-1$层到第$l$层的权重矩阵
- $\bv_l \in \Rbb^{n_l}$：第$l$层的偏置 (截距)
- $\zv_l \in \Rbb^{n_l}$：第$l$层神经元的输入
- $\av_l \in \Rbb^{n_l}$：第$l$层神经元的输出

<div class="top4"></div>

神经网络第$l$层的计算过程：$\zv_l = \Wv_l \av_{l-1} + \bv_l$，$\av_l = h_l (\zv_l)$

整个网络：$\xv = \av_0 \xrightarrow{\Wv_1,\bv_1} \zv_1 \xrightarrow{h_1} \av_1 \xrightarrow{\Wv_2,\bv_2} \cdots \xrightarrow{\Wv_L,\bv_L} \zv_L \xrightarrow{h_L} \av_L = \hat{\yv}$

<!-- slide data-notes="" -->

##### 激活函数

---

最早的 M-P 模型采用阶跃函数$\sgn(\cdot)$作为激活函数

改进方向：

- 连续并几乎处处可导，可以高效计算
- 导数的值域在合适的范围内，否则影响用梯度下降进行训练

<div class="top2"></div>

常见的有

- Sigmoid 型：Logistic 函数，Tanh 函数
- ReLU，带泄漏的 ReLU，带参数的 ReLU，ELU，Softplus
- Swish 函数
- Maxout 单元

<!-- slide vertical=true data-notes="" -->

##### Sigmoid 型

---

<img src="../python/Sigmoid.svg" class="width60 center top6">

<!-- slide vertical=true data-notes="" -->

##### Logistic 函数

---

将$\Rbb$<span class="blue">挤压</span>到$[0,1]$，输出拥有概率意义：

$$
\begin{align*}
    \sigma(z) = \frac{1}{1 + \exp (-z)} = \begin{cases}
        1 & z \rightarrow \infty \\
        0 & z \rightarrow -\infty
    \end{cases}
\end{align*}
$$

Logistic 函数连续可导，在<span class="blue">零处导数最大</span>

$$
\begin{align*}
    \sigma'(z) & = - \frac{- \exp (-z)}{(1 + \exp (-z))^2} = \frac{1}{1 + \exp (-z)} \frac{\exp (-z)}{1 + \exp (-z)} \\
    & = \sigma(z) (1 - \sigma(z)) \leq \left( \frac{\sigma(z) + 1 - \sigma(z)}{2} \right)^2 \\
    & = \frac{1}{4}
\end{align*}
$$

均值不等式等号成立的条件是$\sigma(z) = 1 - \sigma(z)$，即$z = 0$

<!-- slide vertical=true data-notes="" -->

##### Tanh 函数

---

将$\Rbb$<span class="blue">挤压</span>到$[-1,1]$，<span class="blue">输出零中心化</span>，Logistic 函数的放大平移

$$
\begin{align*}
    \tanh(z) & = \frac{\exp(z) - \exp(-z)}{\exp(z) + \exp(-z)} = \frac{1 - \exp(-2z)}{1 + \exp(-2z)} \\
    & = 2 \sigma(2z) - 1 \\
    & = \begin{cases}
        1 & z \rightarrow \infty \\
        -1 & z \rightarrow -\infty
    \end{cases}
\end{align*}
$$

性质：

- 连续可导$\tanh'(z) = 2 (\sigma(2z))' = 4 \sigma(2z) (1 - \sigma(2z))$，在$z = 0$处导数最大
- 输出零中心化使得后一层的输入$\wv^\top \av + \bv$也在零附近，而 Tanh 函数在零处导数最大，梯度下降更新效率较高，Logistic 函数输出恒为正，会进一步减慢梯度下降的收敛速度

<!-- slide data-notes="梯度消失之后在讲了BP之后会细讲 <br><br> 死亡relu在下一页" -->

HEADER ReLU

ReLU 全称叫修正线性单元 (**re**ctified **l**inear **u**nit)，定义为

$$
\begin{align*}
    \relu(z) = \max \{ 0, z \} = \begin{cases}
        z & z \geq 0 \\ 0 & z < 0
    \end{cases}
\end{align*}
$$

<br>

优点

- 计算只涉及加法、乘法和比较操作，非常高效
- 生物学解释：单侧抑制，宽兴奋边界，稀疏兴奋
- 在$z > 0$时导数恒为$1$，缓解了<span class="blue">梯度消失</span>问题

<br>

缺点

- 输出非零中心化，对下一层不友好
- 死亡 ReLU 问题：对异常值特别敏感

FOOTER3 图神经网络导论 神经网络 tengzhang@hust.edu.cn

<!-- slide vertical=true data-notes="" -->

HEADER 死亡 ReLU 问题

由链式法则有

$$
\begin{align*}
    \frac{\partial \relu(\wv^\top \xv + b)}{\partial \wv} & = \frac{\partial \relu(\wv^\top \xv + b)}{\partial (\wv^\top \xv + b)} \frac{\partial (\wv^\top \xv + b)}{\partial \wv} \\
    & = \frac{\partial \max \{ 0, \wv^\top \xv + b \}}{\partial (\wv^\top \xv + b)} \xv^\top \\
    & = 1_{\wv^\top \xv + b \geq 0} \xv^\top
\end{align*}
$$

如果第一个隐藏层中的某个神经元的权重向量$\wv$初始化不当，使得对任意$\xv$有$\wv^\top \xv + b < 0$，那么其关于$\wv$的梯度将为零，在以后的训练过程中$\wv$永远不会被更新

<br>

方案：带泄漏的 ReLU，带参数的 ReLU，ELU，Softplus

FOOTER3 图神经网络导论 神经网络 tengzhang@hust.edu.cn

<!-- slide vertical=true data-notes="" -->

HEADER ReLU 变体

带泄漏的 ReLU：当$\wv^\top \xv + b < 0$时也有非零梯度

$$
\begin{align*}
    \lrelu(z) & = \begin{cases}
        z & z \geq 0 \\ \gamma z & z < 0
    \end{cases} \\
    & = \max \{ 0, z \} + \gamma \min \{ 0, z \} \overset{\gamma < 1}{=} \max \{ z, \gamma z \}
\end{align*}
$$

其中斜率$\gamma$是一个很小的常数，比如$0.01$

<br>

带参数的 ReLU：斜率$\gamma_i$可学习

$$
\begin{align*}
    \prelu(z) & = \begin{cases}
        z & z \geq 0 \\ \gamma_i z & z < 0
    \end{cases} \\
    & = \max \{ 0, z \} + \gamma_i \min \{ 0, z \}
\end{align*}
$$

可以不同神经元具有不同的参数，也可以一组神经元共享一个参数

FOOTER3 图神经网络导论 神经网络 tengzhang@hust.edu.cn

<!-- slide vertical=true data-notes="" -->

HEADER ReLU 变体

ELU 全称叫指数线性单元 (**e**xponential **l**inear **u**nit)

$$
\begin{align*}
    \elu(z) & = \begin{cases}
        z & z \geq 0 \\ \gamma (\exp(z) - 1) & z < 0
    \end{cases} \\
    & = \max \{ 0, z \} + \min \{ 0, \gamma (\exp(z) - 1) \}
\end{align*}
$$

<div class="bottom4"></div>

Softplus 函数可以看作 ReLU 的平滑版本：

$$
\begin{align*}
    \softplus(z) = \log (1 + \exp(z))
\end{align*}
$$

其导数为 Logistic 函数

$$
\begin{align*}
    \softplus'(z) = \frac{\exp(z)}{1 + \exp(z)} = \frac{1}{1 + \exp(-z)}
\end{align*}
$$

FOOTER3 图神经网络导论 神经网络 tengzhang@hust.edu.cn

<!-- slide vertical=true data-notes="" -->

HEADER ReLU 族

<img src="../python/ReLU.svg" class="width60 center top6">

FOOTER3 图神经网络导论 神经网络 tengzhang@hust.edu.cn

<!-- slide data-notes="自门控的意思是控制自己是否激活的\sigma (\beta z)也跟有关" -->

HEADER Swish 函数

Swish 函数是一种自门控 (self-gated) 激活函数：

$$
\begin{align*}
    \swish(z) = z \cdot \sigma (\beta z) = \frac{z}{1 + \exp(-\beta z)}
\end{align*}
$$

其中$\beta$是可学习的参数或一个固定超参数

- 当$\sigma (\beta z)$接近于$1$时，门处于<span class="blue">开</span>状态，激活函数的输出近似于$z$本身
- 当$\sigma (\beta z)$接近于$0$时，门处于<span class="blue">关</span>状态，激活函数的输出近似于$0$

FOOTER3 图神经网络导论 神经网络 tengzhang@hust.edu.cn

<!-- slide vertical=true data-notes="" -->

HEADER Swish 函数

<img src="../python/Swish.svg" class="width60 center top6">

FOOTER3 图神经网络导论 神经网络 tengzhang@hust.edu.cn

<!-- slide vertical=true data-notes="" -->

HEADER Maxout 单元

考虑神经网络的第$l$层：

$$
\begin{align*}
    \zv_l & = \Wv_l \av_{l-1} + \bv_l \\
    \av_l & = h_l (\zv_l)
\end{align*}
$$

前面提到的激活函数都是$\Rbb \mapsto \Rbb$的，即$[\av_l]_i = h_l ([\zv_l]_i), ~ i \in [n_l]$

<br>

Maxout 单元是$\Rbb^{n_l} \mapsto \Rbb$的，输入就是$\zv_l$，其定义为

$$
\begin{align*}
    \maxout (\zv) = \max_{k \in [K]} \{ \wv_k^\top \zv + b_k \}
\end{align*}
$$

- 整体学习输入到输出间的非线性关系
- $\relu(z) = \max \{ 0, z \}$与$\lrelu(z) \overset{\gamma < 1}{=} \max \{ z, \gamma z \}$都是 Maxout 单元的特例

FOOTER3 图神经网络导论 神经网络 tengzhang@hust.edu.cn

<!-- slide data-notes="" -->

HEADER 应用到机器学习

@import "../dot/ml-nn.dot"

<div></div>

前$L-1$层是复合函数$\psi: \Rbb^d \mapsto \Rbb^{n_{L-1}}$，可以看作一种特征变换方法

<br>

最后一层是学习器$\hat{\yv} = g(\psi(\xv); \Wv_L, \bv_L)$，对输入$\psi(\xv)$进行预测

- 若$y \in \{ \pm 1 \}$，最后一层只需$1$个神经元，并采用 Logistic 激活函数
- 若$y \in [C]$，最后一层需$C$个神经元，并采用 Softmax 激活函数

<br>

因此对数几率回归也可看作只有一层 (没有隐藏层) 的神经网络

FOOTER3 图神经网络导论 神经网络 tengzhang@hust.edu.cn

<!-- slide vertical=true data-notes="" -->

HEADER 深度学习

传统机器学习：特征处理和学习两阶段分开进行

@import "../dot/ml-old.dot"

<br>

深度学习：特征工程和模型学习合二为一，端到端 (end-to-end)

@import "../dot/ml-nn.dot"

FOOTER3 图神经网络导论 神经网络 tengzhang@hust.edu.cn

<!-- slide vertical=true data-notes="" -->

HEADER 用 tensorflow 实现

```python {.line-numbers}
from sklearn.datasets import load_breast_cancer
from sklearn.model_selection import train_test_split
from tensorflow.keras.layers import Dense
from tensorflow.keras.models import Sequential
from tensorflow.keras.optimizers import SGD

X, y = load_breast_cancer(return_X_y=True)
X_train, X_test, y_train, y_test = train_test_split(X, y, random_state=0)

model = Sequential()
model.add(Dense(64, activation="relu"))
model.add(Dense(64, activation="relu"))
model.add(Dense(1, activation="sigmoid"))
model.compile(optimizer=SGD(0.001),
              loss="binary_crossentropy",
              metrics=["accuracy"],
              )

model.fit(X_train, y_train, epochs=10)
model.evaluate(X_test, y_test, verbose=2)

Epoch 1/10
14/14 [================] - 1s 1ms/step - loss: 51.0188 - accuracy: 0.4906
Epoch 2/10
14/14 [================] - 0s 1ms/step - loss: 1.0154 - accuracy: 0.7465
Epoch 3/10
14/14 [================] - 0s 1ms/step - loss: 0.5027 - accuracy: 0.8146
Epoch 4/10
14/14 [================] - 0s 1ms/step - loss: 0.4219 - accuracy: 0.8239
Epoch 5/10
14/14 [================] - 0s 1ms/step - loss: 0.4142 - accuracy: 0.8380
Epoch 6/10
14/14 [================] - 0s 1ms/step - loss: 0.3101 - accuracy: 0.8779
Epoch 7/10
14/14 [================] - 0s 1ms/step - loss: 0.2744 - accuracy: 0.8944
Epoch 8/10
14/14 [================] - 0s 1ms/step - loss: 0.2454 - accuracy: 0.9061
Epoch 9/10
14/14 [================] - 0s 1ms/step - loss: 0.3001 - accuracy: 0.8897
Epoch 10/10
14/14 [================] - 0s 1ms/step - loss: 0.2557 - accuracy: 0.8991

5/5 - 0s - loss: 0.2264 - accuracy: 0.9231
```

FOOTER3 图神经网络导论 神经网络 tengzhang@hust.edu.cn

<!-- slide data-notes="" -->

HEADER 求解参数

设采用交叉熵损失，对样本$(\xv, y)$，损失函数为$\Lcal (\yv, \hat{\yv}) = - \yv \log \hat{\yv}$

<br>

优化目标为

$$
\begin{align*}
    \min_{\Wv, \bv} ~ \frac{1}{2} \| \Wv \|_F^2 + \frac{\lambda}{m} \sum_{i \in [m]} \Lcal (\yv_i, \hat{\yv}_i)
\end{align*}
$$

<br>

梯度下降 (标量对某矩阵求导的结果的尺寸与该矩阵呈转置关系)

$$
\begin{align*}
    \Wv & ~ \leftarrow ~ \Wv - \eta \left( \frac{\lambda}{m} \sum_{i \in [m]} \class{yellow}{\frac{\partial \Lcal (\yv_i, \hat{\yv}_i)}{\partial \Wv^\top}} + \Wv \right) \\
    \bv & ~ \leftarrow ~ \bv - \eta \cdot \frac{\lambda}{m} \sum_{i \in [m]} \class{yellow}{\frac{\partial \Lcal (\yv_i, \hat{\yv}_i)}{\partial \bv^\top}}
\end{align*}
$$

FOOTER3 图神经网络导论 神经网络 tengzhang@hust.edu.cn

<!-- slide data-notes="" -->

HEADER 求解参数

整个网络：$\xv = \av_0 \xrightarrow{\Wv_1,\bv_1} \zv_1 \xrightarrow{h_1} \av_1 \xrightarrow{\Wv_2,\bv_2} \cdots \xrightarrow{\Wv_L,\bv_L} \zv_L \xrightarrow{h_L} \av_L = \hat{\yv}$

<br>

损失$\Lcal (\yv, \hat{\yv})$的计算为<span class="blue">正向传播</span>

- 样本从输入层进入，经隐藏层逐层传播到最后输出层
- $\hat{\yv} = \av_L = h_L (\zv_L)$是对样本$\xv$的预测，据此计算$\Lcal (\yv, \hat{\yv}) = \Lcal (\yv, h_L (\zv_L))$

<br>

先看最后一层$\zv_L = \Wv_L ~ \av_{L-1} + \bv_L$，$\av_L = h_L (\zv_L)$，由<span class="blue">链式法则</span> (?) 有

$$
\begin{align*}
    \frac{\partial \Lcal (\yv, \hat{\yv})}{\partial \bv_L} & = \frac{\partial \Lcal (\yv, \hat{\yv})}{\partial \zv_L} \frac{\partial \zv_L}{\partial \bv_L} = \deltav_L^\top \frac{\partial \zv_L}{\partial \bv_L} \\
    \frac{\partial \Lcal (\yv, \hat{\yv})}{\partial \Wv_L} & = \sum_{j \in [n_L]} \frac{\partial \Lcal (\yv, \hat{\yv})}{\partial [\zv_L]_j} \frac{\partial [\zv_L]_j}{\partial \Wv_L} = \sum_{j \in [n_L]} [\deltav_L]_j \frac{\partial [\zv_L]_j}{\partial \Wv_L}
\end{align*}
$$

其中$\deltav_L^\top = \partial \Lcal (\yv, \hat{\yv}) / \partial \zv_L \in \Rbb^{n_L}$为第$L$层的<span class="blue">误差项</span>，该项可直接求解

FOOTER3 图神经网络导论 神经网络 tengzhang@hust.edu.cn

<!-- slide vertical=true data-notes="" -->

HEADER 求解参数 反向传播

整个网络：$\xv = \av_0 \xrightarrow{\Wv_1,\bv_1} \zv_1 \xrightarrow{h_1} \av_1 \xrightarrow{\Wv_2,\bv_2} \cdots \xrightarrow{\Wv_L,\bv_L} \zv_L \xrightarrow{h_L} \av_L = \hat{\yv}$

<br>

类似的对第$l$层$\zv_l = \Wv_l \av_{l-1} + \bv_l$，$\av_l = h_l (\zv_l)$，由<span class="blue">链式法则</span> (?) 有

$$
\begin{align*}
    \frac{\partial \Lcal (\yv, \hat{\yv})}{\partial \bv_l} = \deltav_l^\top \frac{\partial \zv_l}{\partial \bv_l}, \quad \frac{\partial \Lcal (\yv, \hat{\yv})}{\partial \Wv_l} = \sum_{j \in [n_l]} [\deltav_l]_j \frac{\partial [\zv_l]_j}{\partial \Wv_l}
\end{align*}
$$

其中$\deltav_l^\top = \partial \Lcal (\yv, \hat{\yv}) / \partial \zv_l \in \Rbb^{n_l}$为第$l$层的<span class="blue">误差项</span>

<br>

误差<span class="blue">反向传播</span> (**b**ack**p**ropagation, BP)：前一层的误差可由后一层得到

$$
\begin{align*}
    \deltav_{l-1}^\top = \frac{\partial \Lcal (\yv, \hat{\yv})}{\partial \zv_{l-1}} = \frac{\partial \Lcal (\yv, \hat{\yv})}{\partial \zv_l} \frac{\partial \zv_l}{\partial \av_{l-1}} \frac{\partial \av_{l-1}}{\partial \zv_{l-1}} = \deltav_l^\top \frac{\partial \zv_l}{\partial \av_{l-1}} \frac{\partial h_{l-1}(\zv_{l-1})}{\partial \zv_{l-1}}
\end{align*}
$$

对第$l$层$\zv_l = \Wv_l \av_{l-1} + \bv_l$，如何求$\partial \zv_l / \partial \av_{l-1}$、$\partial \zv_l / \partial \bv_l$、$\partial [\zv_l]_j / \partial \Wv_l$

FOOTER3 图神经网络导论 神经网络 tengzhang@hust.edu.cn

<!-- slide vertical=true data-notes="" -->

HEADER 求解参数 反向传播

对$\zv = \Wv \av + \bv$，如何求$\partial \zv / \partial \av$、$\partial \zv / \partial \bv$、$\partial z_j / \partial \Wv$

由矩阵求导公式易知

$$
\begin{align*}
    \frac{\partial \zv}{\partial \av} = \frac{\partial (\Wv \av)}{\partial \av} = \Wv, \quad \frac{\partial \zv}{\partial \bv} = \frac{\partial \bv}{\partial \bv} = \Iv
\end{align*}
$$

注意$z_j = \sum_k w_{jk} a_k + b_k$只与$\Wv$的第$j$行有关，于是

$$
\begin{align*}
    \frac{\partial z_j}{\partial \Wv} = \underbrace{\begin{bmatrix} \zerov, \ldots, \av, \ldots, \zerov \end{bmatrix}}_{\text{only }\av\text{ at }j\text{-th column}} = \av \ev_j^\top
\end{align*}
$$

从而

$$
\begin{align*}
    \frac{\partial \Lcal (\yv, \hat{\yv})}{\partial \Wv_l} = \sum_{j \in [n_l]} [\deltav_l]_j \frac{\partial [\zv_l]_j}{\partial \Wv_l} = \av_{l-1} \sum_{j \in [n_l]} [\deltav_l]_j \ev_j^\top = \av_{l-1} \deltav_l^\top
\end{align*}
$$

FOOTER3 图神经网络导论 神经网络 tengzhang@hust.edu.cn

<!-- slide vertical=true data-notes="" -->

HEADER 反向传播算法

输入：训练集$\Scal$，验证集$\Vcal$，以及相关超参数

1. 随机初始化$\Wv$和$\bv$
2. repeat
3. &emsp;&emsp;对训练集$\Scal$中的样本随机重排序
4. &emsp;&emsp;for $i = 1, \ldots, m$ do
5. &emsp;&emsp;&emsp;&emsp;获取样本$(\xv_i, y_i)$
6. &emsp;&emsp;&emsp;&emsp;前向传播，计算每一层的$\zv_l = \Wv_l \av_{l-1} + \bv_l$，直到最后一层
7. &emsp;&emsp;&emsp;&emsp;反向传播计算每一层的误差项$\deltav_l^\top = \deltav_{l+1}^\top \Wv_{l+1} \diag (h_l'(\zv_l))$
8. &emsp;&emsp;&emsp;&emsp;计算梯度$\partial \Lcal / \partial \Wv_l = \av_{l-1} \deltav_l^\top$、$\partial \Lcal / \partial \bv_l = \deltav_l^\top$
9. &emsp;&emsp;&emsp;&emsp;采用梯度下降更新$\Wv_l$和$\bv_l$
10. &emsp;&emsp;end
11. until 神经网络模型在验证集$\Vcal$上的错误率不再下降

输出：$\Wv$和$\bv$

FOOTER3 图神经网络导论 神经网络 tengzhang@hust.edu.cn

<!-- slide data-notes="" -->

HEADER 梯度消失

神经网络中误差反向传播的迭代公式为

$$
\begin{align*}
    \deltav_l^\top = \frac{\partial \Lcal (\yv, \hat{\yv})}{\partial \zv_l} = \frac{\partial \Lcal (\yv, \hat{\yv})}{\partial \zv_{l+1}} \frac{\partial \zv_{l+1}}{\partial \av_l} \frac{\partial \av_l}{\partial \zv_l} = \deltav_{l+1}^\top \Wv_{l+1} \diag (h_l'(\zv_l))
\end{align*}
$$

<br>

对于 Sigmoid 型激活函数

- $\sigma'(z) = \sigma(z) (1 - \sigma(z)) \leq \frac{1}{4}$
- $\tanh'(z) = 4 \sigma(2z) (1 - \sigma(2z)) \leq 4 \cdot \frac{1}{4} = 1$

<br>

误差每传播一层都会乘以一个小于等于$1$的系数，当网络层数很深时，梯度会不断衰减甚至消失，使得整个网络很难训练

<br>

方案：使用导数比较大的激活函数，比如 ReLU

FOOTER3 图神经网络导论 神经网络 tengzhang@hust.edu.cn

<!-- slide vertical=true data-notes="" -->

HEADER 残差网络

<img src="../tikz/resnet.svg" class="width75 center top2 bottom2">

残差模块：$\zv_l = \av_{l-1} + \class{yellow}{\Uv_2 \cdot h(\Uv_1 \cdot \av_{l-1} + \cv_1) + \cv_2} = \av_{l-1} + \class{yellow}{f(\av_{l-1})}$

假设$\av_l = \zv_l$，即残差模块输出不使用激活函数，对$\forall t \in [l]$有

$$
\begin{align*}
    \av_l & = \av_{l-1} + f(\av_{l-1}) = \av_{l-2} + f(\av_{l-2}) + f(\av_{l-1}) \\
    & = \cdots = \av_{l-t} + \sum_{i=l-t}^{l-1} f(\av_i)
\end{align*}
$$

低层输入可以<span class="blue">恒等</span>传播到任意高层

FOOTER3 图神经网络导论 神经网络 tengzhang@hust.edu.cn

<!-- slide vertical=true data-notes="" -->

HEADER 残差网络

$$
\begin{align*}
    \av_l = \av_{l-t} + \sum_{i=l-t}^{l-1} f(\av_i)
\end{align*}
$$

由链式法则有

$$
\begin{align*}
    \frac{\partial \Lcal}{\partial \av_{l-t}} & = \frac{\partial \Lcal}{\partial \av_l} \frac{\partial \av_l}{\partial \av_{l-t}} = \frac{\partial \Lcal}{\partial \av_l} \left( \frac{\partial \av_{l-t}}{\partial \av_{l-t}} + \frac{\partial }{\partial \av_{l-t}} \sum_{i=l-t}^{l-1} f(\av_i) \right) \\
    & = \frac{\partial \Lcal}{\partial \av_l} \left( \Iv + \frac{\partial }{\partial \av_{l-t}} \sum_{i=l-t}^{l-1} f(\av_i) \right) \\
    & = \frac{\partial \Lcal}{\partial \av_l} + \frac{\partial \Lcal}{\partial \av_l} \left( \frac{\partial }{\partial \av_{l-t}} \sum_{i=l-t}^{l-1} f(\av_i) \right)
\end{align*}
$$

高层误差可以<span class="blue">恒等</span>传播到任意低层，梯度消失得以缓解
